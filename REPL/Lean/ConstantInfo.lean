import REPL.Lean.ContextInfo
import REPL.Lean.DeclarationInfo

namespace Lean.Elab

deriving instance BEq for QuotKind, QuotVal, InductiveVal, ConstantInfo

def constKind : ConstantInfo → String
  | .defnInfo   _ => "definition"  -- a "def"
  | .axiomInfo  _ => "axiom"
  | .thmInfo    _ => "theorem"
  | .opaqueInfo _ => "opaque"
  | .quotInfo   _ => "Quot"  -- from quotients (Quot/Quot.mk/Quot.lift/Quot.ind)
  | .inductInfo _ => "inductive"  -- One for each inductive datatype in a mutual declaration.
  | .ctorInfo   _ => "constructor"  -- Of an inductive type; one per Constructor in mutual decl.
  | .recInfo    _ => "recursor" -- Generated by mutual declaration.

structure ConstantInfo.Json where
  name : Name -- full name
  kind: String
  levelParams: List Name := []  -- https://lean-lang.org/doc/reference/latest/The-Type-System/Universes/#--tech-term-universe-parameters
  type : String  -- The constant's type Expr, pretty-printed (for a theorem, this is the statement without binders).
  value: Option String  := none -- The constant's value Expr, pretty-printed (for a theorem, this is the proof, as an unreduced term).
  isProp: Bool := false  -- Whether type is a Prop.
  isUnsafe: Bool := false  -- see https://lean-lang.org/doc/reference/latest/Definitions/Modifiers/#declaration-modifiers
  isPartial: Bool := false
  byteRange: Option String.Range := none

def Json.nonemptyList [ToJson α] (k : String) : List α → List (String × Json)
  | [] => []
  | l  => [⟨k, toJson l⟩]

def Json.nonfalse (k : String) : Bool → List (String × Json)
  | false => []
  | true  => [⟨k, toJson true⟩]

instance : ToJson ConstantInfo.Json where
  toJson c := Json.mkObj <| .join [
    [("name", toJson c.name)],
    [("kind", c.kind)],
    [("type", c.type)],
    Json.opt "value" c.value,
    Json.nonemptyList "levelParams" c.levelParams,
    [("isProp", c.isProp)],
    Json.nonfalse "isUnsafe" c.isUnsafe,
    Json.nonfalse "isPartial" c.isPartial,
    Json.opt "byteRange" c.byteRange,
  ]


private def nameTail : Name → String
  | Name.str _ s => s
  | _ => ""


def constInfoToJson (c: ConstantInfo) (r?: Option DeclarationRanges) (ctx : ContextInfo) : IO (Option ConstantInfo.Json) := do
  if (nameTail c.name).startsWith "_" then
    return none

  let declRange: Option DeclarationRange := r?.map (·.range)
  let range: Option String.Range := declRange.map
    fun r => ⟨ctx.fileMap.ofPosition r.pos, ctx.fileMap.ofPosition r.endPos⟩

  return some {
    name := c.name,
    kind := constKind c,
    levelParams := c.levelParams,
    type := (← ctx.ppExpr {} c.type).pretty,
    isProp := ← ctx.runMetaM {} <| Lean.Meta.isProp c.type,
    isUnsafe := c.isUnsafe,
    isPartial := c.isPartial,
    value := ← c.value?.mapM (fun v => do pure (← ctx.ppExpr {} v).pretty),
    byteRange := range
  }

def constantsToJson (constants: Array (ConstantInfo × Option DeclarationRanges)) (ctx : ContextInfo) : IO (Array ConstantInfo.Json) := do
  constants.filterMapM (fun ⟨c, r?⟩ => constInfoToJson c r? ctx)


def getTopLevelContextInfo (infoTree: InfoTree) : Option ContextInfo :=
  match infoTree with
  | .context c _ => c.mergeIntoOuter? none
  | _ => none

def getNewConstants (newConstMap: ConstMap) (previousConstMap: ConstMap) (newCtxInfo: ContextInfo)
      : IO (Array ConstantInfo.Json) := do
    -- Get local constants only.
    -- (Alternatively we could use `(← Lean.mkModuleData cmdState.env).constants`).

    -- Minor remark:
    -- this only happens for one file in all of mathlib:
    -- if a constant with the same namespaced name already exists in imports
    -- and is shadowed by a new declaration (same namespace, same name)
    -- we won't see it, probably because it gets updated in stage1;
    -- unfortunately iterating over all of stage1 is too slow.

    let constants := newConstMap.foldStage2 (fun cs _ c => cs.push c) #[]
    let newConstants := constants.filter $ fun c =>
      match previousConstMap.find? c.name with
      | none => true
      | some old => c != old
    let ranges ← newCtxInfo.runCoreM' $
      newConstants.mapM fun c => Lean.findDeclarationRanges? c.name
    constantsToJson (Array.zip newConstants ranges) newCtxInfo

def collectNewConstantsPerTree (infoTrees: List InfoTree) (initialConstMap: ConstMap) : IO (Array (Array ConstantInfo.Json)) := do
  let mut previousConstMap := initialConstMap
  let mut result: Array (Array ConstantInfo.Json) := {}

  for infoTree in infoTrees do
    let ctxInfo? := getTopLevelContextInfo infoTree
    match ctxInfo? with
    | some ctxInfo => do
      let newConstMap := ctxInfo.env.constants
      result := result.push <| ← getNewConstants newConstMap previousConstMap ctxInfo
      previousConstMap := newConstMap
    | none => do
      result := result.push #[]
      continue

  return result
